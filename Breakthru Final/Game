class Game:
    def __init__(self, game_interface):
        self.game_interface = game_interface

    def make_move_cpu(self):
        best_move = self.minimax(self.game_interface, depth=3, maximizing_player=True)
        if best_move:
            x, y = best_move[1]
            self.game_interface.executar_movimento(x, y)

    def minimax(self, game_interface, depth, maximizing_player, alpha=float('-inf'), beta=float('inf')):
        if depth == 0 or game_interface.is_game_over():
            return self.evaluate(game_interface), None

        if maximizing_player:
            max_eval = float('-inf')
            best_move = None
            for move in game_interface.get_available_moves():
                new_game_interface = game_interface.make_move(move)
                eval, _ = self.minimax(new_game_interface, depth - 1, False, alpha, beta)
                if eval > max_eval:
                    max_eval = eval
                    best_move = move
                alpha = max(alpha, eval)
                if beta <= alpha:
                    break
            return max_eval, best_move
        else:
            min_eval = float('inf')
            best_move = None
            for move in game_interface.get_available_moves():
                new_game_interface = game_interface.make_move(move)
                eval, _ = self.minimax(new_game_interface, depth - 1, True, alpha, beta)
                if eval < min_eval:
                    min_eval = eval
                    best_move = move
                beta = min(beta, eval)
                if beta <= alpha:
                    break
            return min_eval, best_move

    def evaluate(self, game_interface):

